#### Linux GDT

在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。所有的 GDT 都存放在 `cpu_gdt_table` 数组中，而所有 GDT 的地址和它们的大小（当初始化 `gdtr` 寄存器时使用）被存放在 `cpu_gdt_descr` 数组中。如果你到源代码索引中查看，可以看到这些符号都在文件 *arch/i386/kernel/head.S* 中被定义。本书中的每一个宏、函数和其他符号都被列在源代码索引中，所有能在源代码中很方便地找到它们。

图 2-6 是 GDT 的布局示意图。每个 GDT 包含 18 个段描述符和 14 个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够片于同一个 32 字节的硬件高速缓存行中（参见本章后面 “硬件高速缓存” 一节）。

![图 2-6：全局描述符表](../static/2_6.jpg)

每一个 GDT 中包含的 18 个段描述符指向下列的段：
- 用户态和内核态下的代码段和数据段共 4 个（参见前面一节）。
- 任务状态段（TSS），每个处理器有 1 个。每个 TSS 相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在 `init_tss` 数组中；值得特别说明的是，第 n 个 CPU 的 TSS 描述符的 `Base` 字段指向 `init_tss` 数组的第 n 个元素。G（粒度）标志被清 0，而 `Limit` 字段置为 `0xeb`，因为 TSS 段是 236 字节长。`Type` 字段置为 9 或 11（可用的 32 位 TSS），且 `DPL` 置为 0，因为不允许用户态下的进程访问 TSS 段。在第三章 “任务状态段” 一节你可以找到 Linux 是如何使用 TSS 的细节。
