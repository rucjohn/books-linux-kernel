## Linux 中的分段

80x86 微处理器中的分段鼓励程序把他们的程序化分成逻辑上相关的实体，例如子程序或者全局与局部数据区。然而，Linux 以非常有限的方式使用分段。实际上，分段和分页在某种程度上有点多余，因为它们都可以划分进程的物理地址空间：分段可以给每一直进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间。与分段相比，Linux更喜欢使用分页方式。因为：

- 当所有进程使用相同的段寄存器时，内存管理变得更简单，也就是说它们能共享同样的一组线性地址。  
&emsp;

- Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC 体系结构对分段的支持很有限。  
&emsp;

运行在用户态的所有 Linux 进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有 Linux 进程都使用一对相同的段对指令和数据寻址：它们分别叫做内核代码段和内核数据段。

表 2-3：四个主要的 Linux 段的段描述符字段的值  
段 | Base | G | Limit | S | Type | DPL | D/B | P
--- | --- | --- | --- | --- | --- | --- | --- | ---
用户代码段 | 0x00000000 | 1 | 0xfffff | 1 | 10 | 3 | 1 | 1
用户数据段 | 0x00000000 | 1 | 0xfffff | 1 | 2 | 3 | 1 | 1
内核代码段 | 0x00000000 | 1 | 0xfffff | 1 | 10 | 0 | 1 | 1
内核数据段 | 0x00000000 | 1 | 0xfffff | 1 | 2 | 0 | 1 | 1

相应的段选择符由宏 `__USER_CS`、`__USER_DS`、`__KERNEL_CS` 和 `__KERNEL_DS` 分别定义。例如，为了对内核代码段寻址，内核只需要把 `__KERNEL_CS` 宏产生的值装进 cs 段寄存器即可。

> 注意，与段相关的线性地址从 0 开始，达到 $$2^{32} - 1$$ 的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。

所有的段都从 0x00000000 开始，这可以得出另一个重要结论，那就是在 Linux 下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。

如前所述，CPU 的当前特权级（CPL）反映了进程是在用户态还是内核态，并由存放在 cs 寄存器中的段选择符的 RPL 字段指定。只要当前特权级被改变，一些段寄存器必须相应的更新。例如，当 CPL = 3 时（用户态），ds 寄存器必须含有用户数据段的段选择符，而当 CPL = 0 时（内核态），ds 寄存器必须含有内核数据段的段选择符。

类似的情况也出现在 ss 寄存器中。当 CPL = 3 时，它必须指向一个用户数据段中的用户栈，而当 CPL = 0 时，它必须指向内核数据段的一个内核栈。当从用户态切换到内核态时，Linux 总是确保 ss 寄存器装有内核数据段的段选择符。

当对指向指令数据结构的指针进行保存时，内核根本不需要为其设置逻辑地址的段选择符，因为 cs 寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条 `call` 汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在 cs 寄存器中了。因为 “在内核态执行” 的段只有一种，叫做代码段，由宏 `__KERNEL_CS` 定义，所以只要当 CPU 切换到内核态时将 `__KERNEL_CS` 装载进 cs 就足够了。同样的道理也适用指向内核数据结构的指针（隐含地址使用 ds 寄存器）以及指向用户数据结构的指针（内核显式地使用 es 寄存器）。

除了 刚才描述的 4 个段以外，Linux 还使用了其他几个专门的段。我们将在下一节讲述 Linux GDT 的时候介绍它们。
