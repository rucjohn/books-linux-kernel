# 内核线程

传统的 Unix 系统把一些重要的任务委托给周期性执行的进程，这些任务包括刷新磁盘高速缓存，交换出不用的贡框，维护网络连接等等。事实上，以严格线性的方式执行这些任务的确效率不高，如果把它们放在后台调度，不管是对它们的函数还是对终端用户进程都能得到较好的响应。因为一些系统进程只运行在内核态，所以现代操作系统把它们的函数委托给内核线程（*kernel thread*），内核线程不受不必要的用户态上下文的拖累。

在 Linux 中，内核线程在以下几方面不同于普通进程：  
- 内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。
- 因为内核线程只运行在内核态，它们只使用大于 PAGE_OFFSET 的线性地址空间。另一方面，不管在用户态还是在内核态，普通进程可以用 4GB 的线性地址空间。

## 创建一个内核线程

`kernel_thread()` 函数创建一个新的内核线程，它接受的参数有：所要执行的内核函数的地址（fn）、要传递给函数的参数（arg）、一组clone标志（flags）。该函数本质
上以下面的方式调用 `do_fork()`：  

```
do_fork(flags|CLONE_VM|CLONE_UNTRACED，O，pregs，0，NULL，NULL);
```

CLONE_VM 标志避免复制调用进程的页表：由于新内核线程无论如何都不会访问用户态地址空间，所以这种复制无疑会造成时间和空间的浪费。CLONE_UNTRACED 标志保证不会有任何进程跟踪新内核线程，即使调用进程被跟踪。 
传递给 `do_fork()` 的参数 pregs 表示内核栈的地址，`copy_thread()` 函数将从这里找到为新线程初始化 CPU 寄存器的值。`kernel_thread()` 函数在这个栈中保留寄存器值的目的是：  
- 通过 `copy_thread()` 把 ebx 和 edx 分别设置为参数 fn 和 arg 的值。
- 把 eip 寄存器的值设置为下面汇编语言代码段的地址：
  ```
  movl %edx,%eax
  pushl %edx
  call *%ebx
  pushl %eax
  call do_exit
  ```
  
因此，新的内核线程开始执行 `fn(arg)` 函数，如果该函数结束，内核线程执行系统调用 `_exit()`，并把 `fn()` 的返回值传递给它（参见本章稍后 “撤消进程” 一节）。
