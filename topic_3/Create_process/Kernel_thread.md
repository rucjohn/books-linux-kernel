# 内核线程

传统的 Unix 系统把一些重要的任务委托给周期性执行的进程，这些任务包括刷新磁盘高速缓存，交换出不用的贡框，维护网络连接等等。事实上，以严格线性的方式执行这些任务的确效率不高，如果把它们放在后台调度，不管是对它们的函数还是对终端用户进程都能得到较好的响应。因为一些系统进程只运行在内核态，所以现代操作系统把它们的函数委托给内核线程（*kernel thread*），内核线程不受不必要的用户态上下文的拖累。

在 Linux 中，内核线程在以下几方面不同于普通进程：  
- 内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。
- 因为内核线程只运行在内核态，它们只使用大于 PAGE_OFFSET 的线性地址空间。另一方面，不管在用户态还是在内核态，普通进程可以用 4GB 的线性地址空间。

## 创建一个内核线程

`kernel_thread()` 函数创建一个新的内核线程，它接受的参数有：所要执行的内核函数的地址（fn）、要传递给函数的参数（arg）、一组clone标志（flags）。该函数本质
上以下面的方式调用 `do_fork()`：  

```
do_fork(flags|CLONE_VM|CLONE_UNTRACED，O，pregs，0，NULL，NULL);
```

CLONE_VM 标志避免复制调用进程的页表：由于新内核线程无论如何都不会访问用户态地址空间，所以这种复制无疑会造成时间和空间的浪费。CLONE_UNTRACED 标志保证不会有任何进程跟踪新内核线程，即使调用进程被跟踪。 
传递给 `do_fork()` 的参数 pregs 表示内核栈的地址，`copy_thread()` 函数将从这里找到为新线程初始化 CPU 寄存器的值。`kernel_thread()` 函数在这个栈中保留寄存器值的目的是：  
- 通过 `copy_thread()` 把 ebx 和 edx 分别设置为参数 fn 和 arg 的值。
- 把 eip 寄存器的值设置为下面汇编语言代码段的地址：
  ```
  movl %edx,%eax
  pushl %edx
  call *%ebx
  pushl %eax
  call do_exit
  ```
  
因此，新的内核线程开始执行 `fn(arg)` 函数，如果该函数结束，内核线程执行系统调用 `_exit()`，并把 `fn()` 的返回值传递给它（参见本章稍后 “撤消进程” 一节）。

## 进程 0

所有进程的祖先叫做进程 0，*idle* 进程或因为历史的原因叫做 *swapper* 进程，它是在 Linux 的初始化阶段从无到有创建的一个内核线程（参见附录一）。这个祖先进程使用下列静态分配的数据结构（所有其他进程的数据结构都是动态分配的）：
- 存放在 init_task 变量中的进程描述符，由 `INIT_TASK` 宏完成对它的初始化。
- 存放在 init_thread_union 变量中的 thread_info 描述符和内核堆栈，由 `INIT_THREAD_INFO` 宏完成对它们的初始化。
- 由进程描述符指向的下列表：
  - init_mm
  - init_fs
  - init_files
  - init_signals
  - init_sighand
  
  这些表分别由下列宏初始化：
  - INIT_MM
  - INIT_FS
  - INIT_FILES
  - INIT_SIGNALS
  - INIT_SIGHAND
- 主内核页全局目录存放在 swapper_pg_dir 中（参见第二章“内核页表”一节）。

`start_kernel()` 函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程的内核线程（一般叫做 *init* 进程）：  
```
kernel_thread(init, NULL, CLONE_FS|CLONE_SIGHAND)；
```

新创建内核线程的 PID 为 1，并与进程 0 共享每进程所有的内核数据结构。此外，当调度程序选择到它时，*init* 进程开始执行 `init()` 函数。

创建 *init* 进程后，进程 0 执行 `cpu_idie()` 函数，该函数本质上是在开中断的情况下重复执行 hlt 汇编语言指令（参见第四章）。只有当没有其他进程处于 TASK_RUNNING 状态时，调度程序才选择进程 0。

在多处理器系统中，每个 CPU 都有一个进程 0。只要打开机器电源，计算机的 BIOS 就启动某一个 CPU，同时禁用其他 CPU。运行在 CPUO 上的 swapper 进程初始化内核数据结构，然后激活其他的 CPU，并通过`copy_process()` 函数创建另外的 swapper 进程，把 0 传递给新创建的 swapper 进程作为它们的新 PID。此外，内核把适当的 CPU 索引赋给内核所创建的每个进程的 thread_info 描述符的 cpu 字段。

## 进程 1

由进程 0 创建的内核线程执行 `init()` 函数，`init()` 依次完成内核初始化。`init()` 调用 `execve()` 系统调用装入可执行程序 *init*。结果，*init* 内核线程变为一个普通进程，且拥有自己的每进程（per-process）内核数据结构（参见第二十章）。在系统关闭之前，*init* 进程一直存活，因为它创建和监控在操作系统外层执行的所有进程的活动。

## 其他内核线程

Linux 使用很多其他内核线程。其中一些在初始化阶段创建，一直运行到系统关闭，而其他一些在内核必须执行一个任务时 “按需” 创建，这种任务在内核的执行上下文中得到很好的执行。

一些内核线程的例子（除了进程 0 和进程 1）是：

* *keventd（也被称为事件）*  
执行keventd_wa工作队列（参见第四章）中的函数。  
&emsp;

* *kapmd*  
处理与高级电源管理（APM）相关的事件。  
&emsp;

* *kswapd*  
执行内存回收，在第十七章 “周期回收” 一节将进行描述。  
&emsp;

* *pdflush*  
刷新 “脏” 缓冲区中的内容到磁盘以回收内存，在第十五章 “pdflush内核线程” 一节将进行描述。  
&emsp;

* *kblockd*  
执行 kblockd_workqueue 工作队列中的函数。实质上，它周期性地激活块设备驱动程序，将在第十四章 “激活块设备驱动程序” 一节给予描述。  
&emsp;

* *ksoftirgd*  
运行 tasklet（参看第四章 “软中断及tasklet” 一节）；系统中每个 CPU 都有这样一个内核线程。

