# TASK_RUNNING 状态的进程链表

当内核寻找一个新进程在 CPU 上运行时，必须只考虑可运行进程（即处在 TASK_RUNNING 状态的进程）。

早先的 Linux 版本把所有的可运行进程都放在同一个叫做运行队列（*runqueue*）的链表中，由于维持链表中的进程按优先级排序开销过大，因此，早期的调度程序不得不为选择 “最佳” 可运行进程而扫描整个队列。

Linux 2.6 实现的队列有所不同。其目的是让调度程序能在固定的时间内选出 “最佳” 可运行进程，与队列中可运行的进程数无关。我们仅在此提供一些基本信息，第七章会详细描述这种新的运行队列。

提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。每个 task_struct 描述符包含一个 list_head 类型的字段 run_list。如果进程优先权等于 *k* （其取值范围是 0 到 139），run_list 字段把该进程链入优先权为 *k* 的可运行进程的链表中。此外，在多处理器系统中，每个 CPU 都有它自己的运行队列，即它自己的进程链表集。这是一个通过使数据结构更复杂来改善性能的典型例子：调度程序的操作效率的确提高了，但运行队列的链表却为此被拆分成 140 个不同的队列！

正如我们将看到的，内核必须为系统中每个运行队列保存大量的数据，不过运行队列的主要数据结构还是组成运行队列的进程描述符链表，所有这些链表都由一个单独的 `prio_array_t` 数据结构来实现，其字段说明如表 3-2 所示。

字段 | 类型 | 描述
--- | --- | ---
nr_active | int | 链表中进程描述符的数量
bitmap | unsigned long [5] | 优先权位图：当且仅当某个优先权的进程链表不为空时设置相应的位标志
queue | struct list_head [140] | 140 个优先权队列的头结点

`enqueue_task(p,array)` 函数把进程描述符插入某个运行队列的链表，其代码本质上等同于：
```
list_add_tail(&p->run_list, &array->queue[p->prio]);
__set_bit(p->prio, array->bitmap);
p>array = array;
```

进程描述符的 prio 字段存放进程的动态优先权，而 array 字段是一个指针，指向当前运行队列的 prio_array_t 数据结构。类似地，`dequeue_task(p,array)` 函数从运行队列的链表中删除一个进程的描述符。
