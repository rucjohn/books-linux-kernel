# 标识一个进程

一般来说，能被独立调度的每个执行上下文都必须拥有它自己的进程描述符；因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的 task_struct 结构。

进程和进程描述符之间有非常严格的一一对应关系，这使得用 32 位进程描述符地址标识进程成为一种方便的方式。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。

> 正在已经在第二章的 “Linux 中的分段” 一节中说明的那样，尽管从技术上说，这 32 位仅仅是一个逻辑地址的偏移量部分，蛤它们与线性地址相一致。

另一方面，类 Unix 操作系统允许用户使用一个叫做进程标识符 *process ID, PID* 的数来标识进程，PID存放在进程描述符的 pid 字段中。PID 被顺序编号，新创建进程的 PID 通常是前一个进程的 PID + 1。不过，PID 的值有一个上限，当内核使用的 PID 达到这个上限值的时候就必须开始循环使用已闲置的小 PID 号。在缺省情况下，最大的 PID 号是 32767（`PID_MAX_DEFAULT-1`）；系统管理员可以通过往 `/proc/sys/kernel/pid_max` 写入一个更小的值来减小 PID 的上限值，使 PID 的上限小于 32767。（/proc 是一个特殊文件系统的安装点，参看第十二章 “特殊文件系统” 一节。）在 64 位体系结构中，系统管理员可以把 PID 的上限扩大到 4194303。

由于循环使用 PID 编号，内核必须通过管理一个 pidmap-array 位图来表示当前已分配的 PID 和闲置的 PID。因为一个页框包含 32768 个位，所以在 32 位体系结构中 pidmap-array 位图存放在一个单独的页中。然而，在 64 位体系结构中，当内核分配了超过当前位图大小的 PID 号时，需要为 PID 位图增加更多的页。系统会一直保存这些页不被释放。 

Linux 把不同的 PID 与系统中每个进程或轻量级进程相关联（本章后面我们会看到，在多处理器系统上稍有例外）。这种方式能提供最大的灵活性，因为系统中每个执行上下文都可以被唯一地识别。

另一方面，Unix 程序员希望同一组中的线程有共同的 PID。例如，把指定 PID 的信号发送级组中的所有线程。事实上，POSIX 1003.1c 标准规定一个多线程应用程序中的所有线程都必须有相同的 PID。

遵照这个标准，Linux 引入线程组的表示。一个线程组中的所有线程使用和该线程组的领头线程（*thread group leader*）相同的 PID，也就是该组中第一个轻量级进程的 PID，它被存入进程描述符的 tgid 字段中。`getpid()` 系统调用返回当前进程的 tgid 值而不是 pid 值，因此，一个多线程应用的所有线程共享相同的 PID。绝大多数进程都属于一个线程组，包含单一的成员；线程组的领头线程其 tgid 的值与 pid 的值相同，因而 `getpid()` 系统调用这类进程所起的作用和一般进程是一样的。

下面，我们将向你说明如何从进程的 PID 中有效地导出它的描述符指针。效率至关重要，因为像 `kill()` 这样的很多系统调用使用 PID 表示所操作的进程。





## 进程链表

我们首先介绍双向链表的每个例子 --- 进程链表，进程链表把所有进程的描述符链表起来。每个 task_struct 结构都包含一个 list_head 类型的 tasks 字段，这个类型的 prev 和 next 字段分别指向前面和后面的 task_struct 元素。

进程链表的头是 init_task 描述符，它是所谓的 0 进程（*process 0*）或 *swapper* 进程的进程描述符（参见本章 “内核线程” 一节）。init_task 的 tasks.prev 字段指向链表中最后插入的进程描述符的 tasks 字段。

`SET_LINKS` 和 `REMOVE_LINKS` 宏分别用于从进程链表中插入和删除一个进程描述符。这些宏考虑了进程间的父子关系（见本章后面 “如何组织进程” 一节）。

还有一个很有用的宏就是 `for_each_process`，它的功能是扫描整个进程链表，其定义如下：
```
# define for_each_process(p) \
    for (p=&init_task; (p=list_entry((p)->tasks.next, \
                                     struct task_struct, tasks) \
                                    ) != &init_task; )
```

这个宏是循环控制语句，内核开发者利用它提供循环。注意 init_task 进程描述符是如何起到链表头作用的。这个宏从指向 init_task 的指针开始，把指针移到下一个任务，然后继续，直到又到 init_task 为止（感谢链表的循环性）。在每一次循环时，传递给这个宏的参变量中存放的是当前被扫描进程描述符的地址，这与 `list_entry` 宏的返回值一样。
