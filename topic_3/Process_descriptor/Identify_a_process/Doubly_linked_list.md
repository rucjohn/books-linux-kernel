# 双向链表

在继续阐述内核跟踪系统中各种进程的细节之前，先着重说明实现双向链表的特殊数据结构的作用。

对每个链表，必须实现一组原语操作：初始化链表，插入和删除一个元素，扫描链表等等。这可能既测试结果开发人员的精力，也因为对每个不同的链表都要重复相同的原语操作而造成存储空间的浪费。

因此，Linux 内核定义了 `list_head` 数据结构，字段 next 和 prev 分别表示能用双向链表向前和向后的指针元素。不过，值得特别关注的是，list_head 字段的指针中存放的是另一个 list_head 字段的地址，而不是含有 `list_head` 结构的整个数据结构地址（参见图 3-3（a））。

![图 3-3：用 list_head 数据结构构造的一个双向链表](../static/3_3.jpg)

新链表是用 `LIST_HEAD(list_name)` 宏创建的。它申明类型为 list_head 的新变量 list_name，该变量作为新链表头的占位符，是一个哑元素。`LIST_HEAD(list_name)` 宏还初始化 list_head 数据结构的 prev 和 next 字段，让它们指向 list_name 变量本身。见图 3-3（b）。

有几个实现原语的函数和宏，如表 3-1 所示。

名称 | 说明
--- | ---
`list_add(n,p)` | 把 n 指向的元素插入 p 所指向的特定元素之后（为了把 n 插入在链表的开始，就设置 p 为第一个元素的地址）
`list_add_tail(n,p)` | 把 n 指向的元素插到 p 所指向的特定元素之前（为了把 n 插入到链表的尾部，就设置 p 为第一个元素的地址）
`list_del(p)` | 删除 p 所指向的元素（没有必要指定链表的第一个元素）
`list_empty(p)` | 检查由第一个元素的地址 p 指定的链表是否为空
`list_entry(p,t,m)` | 返回类型为 t 的数据结构的地址，其中类型 t 中含有 list_head 字段 ，而 list_head 字段中含有名字 m 和 地址 p
`list_for_each(p,h)` | 对表头地址 h 指定的链表进行扫描，在每次循环时，通过 p 返回指向链表元素的 list_head 结构的指针
`list_for_each_entry(p,h,m)` | 与 list_for_each 类似，但是返回包含了 list_head 结构的数据结构的地址，而不是 list_head 结构本身的地址

Linux 2.6 内核支持另一种双向链表，其与 list_head 有着明显的区别，因为它不是循环链表，主要用于散列表，对散列表而言重要的是空间而不是在固定的时间内找到表中最后一个元素。表头存放在 hlist_head 数据结构中，该结构只不过是指向表的第一个元素的指针（如果链表为空，那么这个指针为 NULL）。每个元素都是 hlist_node 类型的数据结构，它的 next 指针指向下一个元素，pprev 指针指向前一个元素的 next 字段。因为不是循环链表，所以第一个元素的 pprev 字段和最后个元素的 next 字段都置为 NULL。对这种表可以用类似表 3-1 中的函数和宏（`hlist_add_head()`、`hlist_del()`、`hlist_empty()`、`hlist_entry`、`hlist_for_each_entry`）来操纵。
