# 进程状态

顾名思义，进程描述符中的 state 字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。**在当前的 Linux 版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态；其余的标志将被清除**。下面是进程可能的状态：

* *可运行状态（TASK_RUNNING）*  
进程要么在 CPU 上执行，要么准备执行。  
&emsp;

* *可中断的等待状态（TASK_INTERRUPTIBLE）*  
进程被挂起（睡眠），走到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到 TASK_RUNNING）。  
&emsp;

* *不可中断的等待状态（TASK_UNINTERRUPTIBLE）*  
与可中断的等待状态类似。但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下（进程必须等待，走到一个不能被中断的事件发生），这种状态是很有用的。例如，当进程打一个设备文件，其相应的设备驱动 程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。  
&emsp;

* *暂停状态（TASK_STOPPED）*  
进程的执行被暂停。当进程接收到 `SIGSTOP`、`SIGTSTP`、`SIGTTIN` 或 `SIGTTOU` 信号后，进入暂停状态。  
&emsp;

* *跟踪状态（TASK_TRACED）*  
进程的执行已由 debugger 程序暂停。当一个进程被另一个进程监控时（例如 debugger 执行 `ptrace()` 系统调用监控一个测试程序），任何信号都可以把这个进程置于 TASK_TRACED 状态。  
&emsp;

还有两个进程状态是既可以存放在进程描述符的 state 字段中，也可以存放在 exit_state 字段中。从这两个字段的名称可以看出，只有当进程的执行被终止时，进程的状态才会变为这两种状态中的一种：

* *僵死状态（EXIT_ZOMBIE）*  
进程的执行被终止，但是，父进程还没有发布 `wait4()` 或 `waitpid()` 系统调用来返回有关死亡进程的信息。发布 `wait()` 类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它（参见本章结尾的 “进程删除” 一节）。  
&emsp;

* *僵死撤消状态（EXIT_DEAD）*  
最终状态：由于父进程刚发出 `wait4()` 或 `waitpid()` 系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行 `wait()` 类系统调用（这是一种竞争条件），而把进程的状态由僵死（EXIT_ZOMBIE）状态改为僵死撤消状态（EXIT_DEAD）。  
&emsp;

> 还有其他 `wait()` 类的库函数，如 `wait3()` 和 `wait()`，但在 Linux 中它们是依靠 `wait4()` 和 `waitpid()` 系统调用来实现的。

state 字段的值通常用一个简单的赋值语句设置。例如：
```
p->state = TASK_RUNNING;
```

内核也使用 `set_task_state` 和 `set_current_state` 宏：它们分别设置指定进程的状态和当前执行进程的状态。此外，这些宏确保编译程序或 CPU 控制单元不把赋值操作与其他指令混合。混合指令的顺序有时会导致灾难性的后果（参见第五章）。

