# 进程间的关系

程序创建的进程具有父/子关系。如果一个进程创建多个子进程时，则子进程之间具有兄弟关系。在进程描述符中引入几个字段 来表示这些关系，表示给定进程 P 的这些字段列在表 3-3 中。**进程 0 和 进程 1 是由内核创建的**；稍后我们将看到，进程 1（*init*）是所有进程的祖先。

**表 3-3：进程描述符中表示进程亲属关系的字段的描述**
字段名 | 说明
--- | ---
real_parent | 指向创建了 P 的进程的描述符，如果 P 的父进程不再存在，就指向进程 1（*init*）的描述符（因此，如果用户运行一个后台进程而且退出了 shell，后台进程就会成为 *init* 的子进程）
parent | 指向 P 的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与 real_parent 一致，但偶尔也可以不同，例如，当另一个进程发出监控 P 的 `ptrace()` 系统调用请求时（参见第二十章中 “执行跟踪” 一节）
children | 链表的头部，链表中的所有元素都是 P 创建的子进程
sibling | 指向兄弟进程链表中的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是 P

图 3-4 显示了一组进程间的亲属关系。进程 P0 接连创建了 P1、P2、P3。进程 P3 又创建了 P4。

特别要说明的是，进程之间还存在其他关系：
- 一个进程可能是一个进程组或登录会话的领头进程（参见第一章 “进程管理” 一节）
- 一个进程可能是一个线程组的领头进程（参见本章前面 “标识一个进程” 一节）
- 一个进程可能跟踪其他进程的执行（参见第二十章 “执行跟踪” 一节）

![图 3-4：五个进程间的亲属关系](../static/3_4.jpg)

表 3-4 列出了进程描述符中的一些字段，这些字段 建立起进程 P 和其他进程之间的关系。

**表 3-4：建立非亲属关系的进程描述符字段**
字段名 | 说明
group_leader | P 所在进程组的领头进程的描述符指针
signal->pgrp | P 所在进程组的领头进程的 PID
tgid | P 所在线程组的领头进程的 PID
signal->session | P 的登录会话领头进程的 PID
ptrace_children | 链表的头，该链表包含所有被 debugger 程序跟踪的 P 的子进程
ptrace_list | 指向所跟踪进程其实际父进程链表的前一个和下一个元素（用于 P 被跟踪的时候）

## pidhash 表及链表

在几种情况下，内核必须能从进程的 PID 导出对应的进程描述符指针。例如，为 `kill()` 系统调用提供服务时就会发生这种情况：当进程 P1 希望向另一个进程 P2 发送一个信号时，P1 调用 `kill()` 系统调用，其参数为 P2 的 PID，内核从这个 PID 导出其对应的进程描述符，然后从 P2 的进程描述符中取出记录挂起信号的数据结构指针。

顺序扫描进程链表并检查进程描述符的 pid 字段是可行但相当低效的。为了加速查找，引入了 4 个散列表。需要 4 个散列表是因为进程描述符包含了表示不同类型 PID 的字段（见表 3-5），而且每种类型的 PID 需要它自己的散列表。

**表 3-5：4 个散列表和进程描述符中的相关字段**
Hash 表的类型 | 字段名 | 说明
--- | --- | ---
PIDTYPE_PID | pid | 进程的 PID
PIDTYPE_TGID | tgid | 线程组领头进程的 PID
PIDTYPE_PGID | pgrp | 进程组领头进程的 PID
PIDTYPE_SID | session | 会话领头进程的 PID

内核初始化期间动态地为 4 个散列表分配空间，并把它们的地址存放 pid_hash 数组。一个散列表的长度依赖于可用 RAM 的容量，例如：一个系统拥有 512 MB 的 RAM，那么每个散列表就存在 4 个页框中，可以拥有 2048 个表项。

用 `pid_hashfn` 宏把 PID 转化为表索引，`pid_hashfn` 宏展开为：
```
#define pid_hashfn(x) hash_long((unsigned long) x, pidhash_shift)
```

变量 `pidhash_shift` 用来存放表索引的长度（以位为单位的长度，在我们的例子里是 11 位）。很多散列函数都是使用 `hash_long()`，在 32 位体系结构中它基本等价于：
```
unsigned long hash_long(unsigned long val, unsigned int bits)
{
    unsigned long hash = val * 0x9e370001UL;
    return hash >> (32 - bits);
}
```

因为在我们的例子中 `pidhash_shift == 11`，所以 `pid_hashfn` 的取值范围是 0 到 $$2^{11} - 1 = 2047$$。

正如计算机科学的基础课程所阐述的那样，散列（hash）函数并不总能确保 PID 与表的索引一一对应。两个不同的 PID 散列（hash）到相同的表索引称为冲突（*colliding*）。

```
魔数常量
......
```

Linux 利用链表来处理冲突的 PID：每个表项是由冲突的进程描述符组成的双向链表。

图 3-5 显示了具有两个链表的 PID 散列表。进程号（PID）为 2890 和 29384 的两个进程散列到这个表的第 200 个元素，而进程号（PID）为 29385 的进程散列到这个表的第 1466 个元素。


