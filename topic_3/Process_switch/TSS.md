# 任务状态段

80x86 体系结构包括了一个特殊的段类型，叫任务状态段（*Task State Segment, TSS*）来存放硬件上下文。尽管 Linux 并不使用硬件上下文切换，但是强制它为系统中每个不同的 CPU 创建一个 TSS。这样做的两个主要理由为：

- 当 80x86 的一个 CPU 从用户态切换到内核态时，它就从 TSS 中获取内核态堆栈的地址（参见第四章 “中断和异常的硬件处理” 一节和第十章 “通过 sysenter 指令发送系统调用” 一节）。
- 当用户态进程试图通过 `in` 或 `out` 指令访问一个 I/O 端口时，CPU 需要访问存放在 TSS 中的 I/O 许可权位图（Permission Bitmap）以检查该进程是否有访问端口的权力。

  更确切地说，当进程在用户态下执行 `in` 或 `out` 指令时，控制单元执行下列操作：
  1. 它检查 eflags 寄存器中的 2 位 IOPL 字段。如果该字段值为 3，控制单元就执行 I/O 指令。否则，执行下一位检查。
  2. 访问 tr 寄存器以确定当前的 TSS 和相应的 I/O 许可权位图。
  3. 检查 I/O 指令中指定的 I/O 端口在 I/O 许可权位图中对应的位。如果该位清 0,这条 I/O 指令就执行，否则控制单元产生一个 “General protection” 异常。

tss_struct 结构描述 TSS 的格式。正如第二章所提到的，init_tss 数组为系统上每个不同的 CPU 存放一个 TSS。在每次进程切换时，内核都更新 TSS 的某些字段 以便相应 CPU 控制单元可以安全地检索到它需要的信息。因此，TSS 反映了 CPU 上的当前进程的特权级，但不必为没有在运行的进程保留 TSS。

每个 TSS 有它自己 8 字节的任务状态段描述符（*TAsk State Segment Descriptor, TSSD*）。这个描述符包括指向 TSS 起始地址的 32 位 Base 字段，20 位 Limit 字段。TSSD 的 S 标志位被清 0，以表示相应的 TSS 是系统段的事实（参见第二章 “段描述符” 一节）。

Type 字段置为 11 或 9 以表示这个段实际上是一个 TSS。在 Intel 的原始设计中，系统中的每个进程都应当指向自己的 TSS；Type 字段的第二个有效位叫做 Busy 位；如果进程正由 CPU 执行，则该位置 1，否则置 0。在 Linux 的设计中，每个 CPU 只有一个 TSS，因此，Busy 位总置为 1。

## thread 字段

在每次进程切换时，被替换进程的硬件上下文必须保存在别处。不能像 Intel 原始设计那样反它保存在 TSS 中，因为 Linux 为每个处理器而不是为每个进程使用 TSS。

因此，每个进程描述符包含一个类型为 thread_struct 的 thread 字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后我们会看到，这个数据结构包含的字段涉及大部分 CPU 寄存器，但不包括诸如 eax、ebx 等等这些能用寄存器，它们的值保留在内核堆栈中。
