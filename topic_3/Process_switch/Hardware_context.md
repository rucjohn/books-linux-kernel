# 硬件上下文

尽管每个进程可以拥有属于自己的地址空间，但所有进程必须共享 CPU 寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程的值。

进程恢复执行前必须装入寄存器的一组数据称为硬件上下文（*hardware context*）。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在 Linux 中，进程硬件上下文的一部分存放在 TSS 段，而剩余部分存放在内核态堆栈中。

在下面的描述中，我们假定用 prev 局部变量表示切换出的进程的描述符，next 表示切换进的进程的描述符。因此，我们把进程切换定义为这样的行为：保存 prev 硬件上下文，用 next 硬件上下文代替 next prev。因为进程切换经常发生，因此 减少保存和装入硬件上下文所花费的时间是非常重要的。

早期 Linux 版本利用 80x86 体系结构所提供的硬件支持，并通过 `far jmp` 指令跳到 next 进程 TSS 描述符的选择符来执行进程切换。当执行这条指令时，CPU 通过自动保存原来的硬件上下文，装入新的硬件上下文来执行硬件上下文切换。但基于以下原因，Linux 2.6 使用软件执行进程切换：

- 通过一组 `mov` 指令逐步执行切换，这样能较好地控制所装入数据的合法性。尤其是，这使检查 ds 和 es 段寄存器的值成为可能，这些值有可能被恶意用户伪造。当用单独的 `far jmp` 指令时，不可能进行这类检查。
- 旧方法和新方法所需时间大致相同。然而，尽管当前的切换代码还有改进的余地，却不能对硬件上下文切换进行优化。

进行切换只发生在内核态。在执行进程切换之前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上（参见第四章），这也包括 ss 和 esp 这对寄存器的内容（存储用户态堆栈指针的地址）。

>  `far jmp` 指令既修改 cs 寄存器，也修改 eip 寄存器，而很简单的 `jmp` 指令只修改 eip 指令。
