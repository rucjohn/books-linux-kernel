# 执行进程切换

进程切换可能只发生在精心定义的点：`schedule()` 函数（在第七章会用很长的篇幅来讨论）。这里，我们仅关注内核如何执行一个进程切换。

从本质上说，每个进程切换由两步组成：  
1. 切换页全局目录以安装一个新的地址空间（我们将在第九章描述这一步）；
2. 切换内核态堆栈和硬件上下文，因为硬件上下文件提供了内核执行新进程所需要的所有信息，包含 CPU 寄存器。

我们又一次假定 prev 指向被替换进程的描述符，而 next 指向被激活进程的描述符。我们在第七章会看到，prev 和 next 是 `schedule()` 函数的局部变量。

## switch_to 宏

进程切换的第二步由 `switch_to` 宏执行。它是内核中与硬件关系最密切的例程之一，要理解它到底做了些什么我们必须下些功夫。

首先，该宏有三个参数，它们是 prev、next 和 last。你可能很容易猜到 prev 和 next 的作用：它们仅是局部变量 prev 和 next 的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中位置。

而第三个参数 last 呢？在任何进程切换中，涉及到三个进程而不是两个。假设内核永定暂停进程 A 而激活进程 B。在 `schedule()` 函数中，prev 指向 A 的描述符而 next 指向 B 的描述符。`switch_to` 宏一旦使 A 暂停，A 的执行流就冻结。

随后，当内核想再次激活 A，就必须暂停另一个进程 C（这通常不同于 B），于是就要用 prev 指向 C 而 next 指向 A 来执行另一个 `switch_to` 宏。当 A 恢复它的执行流时，就会找到它原来的内核栈，于是 prev 局部变量还是指向 A 的描述符而 next 指向 B 的描述符。此时，代表进程 A 执行的内核就失去对 C 的任何引用。但是，事实表明这个引用对于完成进程切换是很有用的（更多细节参见第七章）。

`switch_to` 宏的最后一个参数是输出参数，它表示宏把进程 C 的描述符地址写在内存的什么位置了（当然，这是在 A 恢复执行之后完成的）。在进程切换之前，宏把第一个输入参数 prev（即在 A 的内核堆栈中分配的 prev 局部变量）表示的变量的内容存入 CPU 的 eax 寄存器。在完成进程切换，A 已经恢复执行时，宏把 CPU 的 eax 寄存器的内容写入由第三个输出参数 --- last 所指示的 A 在内存中的位置。因为 CPU 寄存器不会在切换点发生变化，所以 C 的描述符地址也存在内存的这个位置。在 `schedule()` 执行过程中，参数 last 指向 A 的局部变量 prev，所以 prev 被 C 的地址覆盖。

图 3-7 显示了进程 A,B,C 内核堆栈的内容以及 eax 寄存器的内容。必须注意的是：图中显示的是在被 eax 寄存器的内容覆盖以前的 prev 局部变量的值。

![图 3-7：通过一个进程切换保留对进程 C 的引用](../static/3_7.jpg)

由于 `switch_to` 宏采用扩展的内联汇编语言编码，所以可读性比较差：实际上这段代码通过特殊位置记数法使用寄存器，而实际使用的能用寄存器由编译器自由选择。我们将采用标准汇编语言而不是麻烦的内联汇编语言来描述 `switch_to` 宏在 80x86 微处理器上所完成的典型工作。

1. eax 和 edx 寄存中分别保存 prev 和 next 的值：  
```
movl prev,%eax
movl next,%edx
```
&emsp;

2. 把 eflags 和 ebp 寄存器的内容保存在 prev 内核栈中。必须保存它们的原因是编译器认为在 `switch_to` 结束之前它们的值应当保持不变。  
```
pushfl
pushl %ebp
```
&emsp;

3. 把 esp 的内容保存到 `prev->thread.esp` 中以使该字段指向 prev 内核栈的栈顶：  
```
movl %esp,484(%eax)
```
484(%eax) 操作数表示内存单元的地址为 eax 内容加上 484。
&emsp;

4. 把 `next->thread.esp` 装入 esp。此时，内核开始在 next 的内核栈上操作，因此这条指令实际上完成了从 prev 到 next 的切换。由于进程描述符的地址和内核栈的地址紧挨着（就像我们在本章前面 “标识一个进程” 一节所解释的），所以改变内核栈意味着改变当前进程。  
```
movl 484(%edx), %esp
```
&emsp;

5. 把标记为 1 的地址（本节后面所示）存入 `prev->thread.eip`。当被替换的进程重新恢复执行时，进程执行被标记为 1 的那条指令：  
```
movl %1f, 480(%eax)
```
&emsp;

6. 宏把 `next->thread.eip` 的值（绝大多数情况下是一个被标记为 1 的地址）压入 next 的内核栈：  
```
pushl 480(%edx)
```
&emsp;

7. 跳到 `__switch_to()` C 函数：  
```
jmp__switch_to
```
&emsp;

8. 这里被进程 B 替换的进程 A 两次获得 CPU：它执行一些保存 eflags 和 ebp 寄存器内容的指令，这两条指令的第一条指令被标记为 1。  
```
1:
    popl %ebp
    popfl
```
注意这些 pop 指令是怎样引用 prev 进程的内核栈的。当进程调度程序选择了 prev 作为新进程在 CPU 上运行时，将执行这些指令。于是，以 prev 作为第二个参数调用 `switch_to`。因此，esp 寄存器指向 prev 的内核栈。  
&emsp;

9. 拷贝 eax 寄存器（上面步骤 1 中被装载）的内容到 `switch_to` 宏的第三个参数 last 标识的内存区域中：  
```
movl %eax, last
```
正如先前讨论的，eax 寄存器指向刚被替换的进程的描述符。  

> 正如本节前面所叙述的，当前执行的 `schedule()` 函数重新使用了 prev 局部变量，于是汇编语言指令就是：`movl %eax,prev`  

&emsp;

