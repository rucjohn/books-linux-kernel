# 执行进程切换

进程切换可能只发生在精心定义的点：`schedule()` 函数（在第七章会用很长的篇幅来讨论）。这里，我们仅关注内核如何执行一个进程切换。

从本质上说，每个进程切换由两步组成：  
1. 切换页全局目录以安装一个新的地址空间（我们将在第九章描述这一步）；
2. 切换内核态堆栈和硬件上下文，因为硬件上下文件提供了内核执行新进程所需要的所有信息，包含 CPU 寄存器。

我们又一次假定 prev 指向被替换进程的描述符，而 next 指向被激活进程的描述符。我们在第七章会看到，prev 和 next 是 `schedule()` 函数的局部变量。

## switch_to 宏

进程切换的第二步由 `switch_to` 宏执行。它是内核中与硬件关系最密切的例程之一，要理解它到底做了些什么我们必须下些功夫。

首先，该宏有三个参数，它们是 prev、next 和 last。你可能很容易猜到 prev 和 next 的作用：它们仅是局部变量 prev 和 next 的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中位置。

而第三个参数 last 呢？在任何进程切换中，涉及到三个进程而不是两个。假设内核永定暂停进程 A 而激活进程 B。在 `schedule()` 函数中，prev 指向 A 的描述符而 next 指向 B 的描述符。`switch_to` 宏一旦使 A 暂停，A 的执行流就冻结。

随后，当内核想再次激活 A，就必须暂停另一个进程 C（这通常不同于 B），于是就要用 prev 指向 C 而 next 指向 A 来执行另一个 `switch_to` 宏。当 A 恢复它的执行流时，就会找到它原来的内核栈，于是 prev 局部变量还是指向 A 的描述符而 next 指向 B 的描述符。此时，代表进程 A 执行的内核就失去对 C 的任何引用。但是，事实表明这个引用对于完成进程切换是很有用的（更多细节参见第七章）。

`switch_to` 宏的最后一个参数是输出参数，它表示宏把进程 C 的描述符地址写在内存的什么位置了（当然，这是在 A 恢复执行之后完成的）。在进程切换之前，宏把第一个输入参数 prev（即在 A 的内核堆栈中分配的 prev 局部变量）表示的变量的内容存入 CPU 的 eax 寄存器。在完成进程切换，A 已经恢复执行时，宏把 CPU 的 eax 寄存器的内容写入由第三个输出参数 --- last 所指示的 A 在内存中的位置。因为 CPU 寄存器不会在切换点发生变化，所以 C 的描述符地址也存在内存的这个位置。在 `schedule()` 执行过程中，参数 last 指向 A 的局部变量 prev，所以 prev 被 C 的地址覆盖。

图 3-7 显示了进程 A,B,C 内核堆栈的内容以及 eax 寄存器的内容。必须注意的是：图中显示的是在被 eax 寄存器的内容覆盖以前的 prev 局部变量的值。


