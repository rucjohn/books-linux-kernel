# 中断和异常

Intel 文档把中断和异常分为以下几类
- 中断：
    - *可屏蔽中断（maskable interrupt）（要根据中断允许标志的设置来判断 CPU 是否能响应中断请求）*  
    I/0 设备发出的所有中断请求（IRQ）都产生可屏蔽中断。可屏酸中断可以处于两种状态：屏蔽的（masked）或非屏蔽的（unmasked）：一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。

    - *非屏蔽中断（nonmaskable interrupt）（不受中断允许标志影响，不能用软件进行屏蔽）*  
    只有几个危急事件（如硬件故障）才引起非屏蔽中断。非屏蔽中断总是由 CPU 辩认。

- 异常：
    - *处理器探测异常（processor-detected exception）* 
    当 CPU 执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组，这取决于 CPU 控制单元产生异常时保存在内核态堆栈 eip 寄存器中的值。
        - *故障（fault）*  
        通常可以纠正；一且纠正，程序就可以在不失连贯性的情况下重新开始。**保存在 eip 中的值是引起故障的指令地址，因此，当异常处理程序终止时，那条指令会被重新执行**。我们将在第九章的 “缺页异常处理程序” 一节中看到，只要处理程序能纠正引起异常的反常条件，重新执行同一指令就是必要的。  
        &emsp;
        - *陷饼（trap）*  
        在陷饼指令执行后立即报告；内核把控制权返回给程序后就可以继续它的执行而不失连贯性。**保存在 eip 中的值是一个随后要执行的指令地址**。只有当没有必要重新执行已终止的指令时，才触发陷饼。**陷阴的主要用途是为了调试程序**。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行（例如到了一个程序内的断点）。一且用户检查到调试程序所提供的数据，她就可能要求被调试程序从下一条指令重新开始执行。  
        &emsp;
        - *异常中止（abort）*  
        发生一个严重的错误：控制单元出了问题，不能在 eip 寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。由控制单元发送的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。  
        &emsp;
        - *编程异常（programmed exception）*  
        在编程者发出请求时发生。是由 int 或 int3 指令触发的：当 into（检查溢出）和 bound（检查地址出界）指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阴来处理。编程异常通常也叫做软中断（*software interrupr*）。这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件（参见第十章）。  

每个中断和异常是由 0～255 之间的一个数来标识。因为一些未知的原因，Intel 把这个 8 位的无符号整数叫做一个向量（*vecror*）。非屏蔽中断的向量和异常的向量是固定的，而可屏酸中断的向量可以通过对中断控制器的编程来改变（参见下一节）。

