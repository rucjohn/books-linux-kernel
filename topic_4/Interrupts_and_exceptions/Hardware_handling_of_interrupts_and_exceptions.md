# 中断和异常的硬件处理

我们现在描述 CPU 控制单元如何处理中断和异常。我们假定内核已被初始化，因此，CPU 在保护模式下运行。

当执行了一条指令后，cs 和 eip 这对寄存器包含下一条将要执行的指令的逻辑地址。在处理那条指令之前，控制单元会检查在运行前一条指令时是否已经发生了一个中断或异常。如果发生了一个中断或异常，那么控制单元执行下列操作：  
1. 确定与中断或异常关联的向量 *i（0 ≤ i ≤ 255）*。  


2. 读由 ldtr 寄存器指向的 IDT 表中的第 *i* 项（在下面的描述中，我们假定 IDT表项中包含的是一个中断门或一个陷阱门）。  
&emsp;

3. 从 gdtr 寄存器获得 GDT 的基地址，并在 GDT 中查找，以读取 IDT 表项中的选择符所标识的段描述符。这个描述符指定中断或异常处理程序所在段的基地址。  
&emsp;

4. 确信中断是由授权的（中断）发生源发出的。首先将当前特权级 CPL（存放在 cs 寄存器的低两位）与段描述符（存放在 GDT 中）的描述符特权级 DPL 比较，如果 CPL 小于 DPL，就产生一个 “General protection” 异常，因为中断处理程序的特权不能低于引起中断的程序的特权。对于编程异常，则做进一步的安全检查：比较 CPL 与处于 IDT 中的门描述符的 DPL，如果 DPL 小于 CPL，就产生一个 “General protection” 异常。这最后一个检查可以避免用户应用程序访问特殊的陷附门或中断门。  
&emsp;

5. 检查是否发生了特权级的变化，也就是说，CPL 是否不同于所选择的段描述符的 DPL。如果是，控制单元必须开始使用与新的特权级相关的栈。通过执行以下步骤
来做到这点：  
    a. 读寄存器，以访问运行进程的 TSS 段。  
    &emsp;

    b. 用与新特权级相关的栈段和栈指针的正确值装载 ss 和 esp 寄存器。这些值可以在 TSS 中找到（参见第三章的 “任务状态段” 一节）。
    &emsp;

    c. 在新的栈中保存 ss 和 esp 以前的值，这些值定义了与旧特权级相关的栈的逻辑地址。  
    &emsp;

6. 如果故障已发生，用引起异常的指令地址装载 cs 和 eip 寄存器，从而使得这条指令能再次被执行。  
&emsp;

7. 在栈中保存 eflags、cs 及 eip 的内容。  
&emsp;

8. 如果异常产生了一个硬件出错码，则将它保存在栈中。  
&emsp;

9. 装载 cs 和 eip 寄存器，其值分别是 IDT 表中第：项门描述符的段选择符和偏移量字段。这些值给出了中断或者异常处理程序的第一条指令的逻辑地址。  
&emsp;

控制单元所执行的最后一步就是跳转到中断或者异常处理程序。换句话说，处理完中断信号后，控制单元所执行的指令就是被选中处理程序的第一条指令。

中断或异常被处理完后，相应的处理程序必须产生一条 iret 指令，把控制权转交给被中断的进程，这将追使控制单元：  

1. 用保存在栈中的值装载 cs、eip 或 eflags 寄存器。如果一个硬件出错码曾被压入栈中，并且在 eip 内容的上面，那么，执行 iret 指令前必须先弹出这个硬件出错码。  
&emsp;

2. 检查处理程序的 CPL 是否等于 cs 中最低两位的值（这意味着被中断的进程与处理程序运行在同一特权级）。如果是，iret 终止执行；否则，转入下一步。  
&emsp;

3. 从栈中装载 ss 和 esp 寄存器，因此，返回到与旧特权级相关的栈。  
&emsp;

4. 检查 ds、es、fs 及 gs 段寄存器的内容，如果其中一个寄存器包含的选择符是一个段描述符，并且其 DPL 值小于 CPL，那么，清相应的段寄存器。控制单元这么做是为了禁止用户态的程序（CPL=3）利用内核以前所用的段寄存器（DPL=0）。如果不清这些寄存器，怀有恶意的用户态程序就可能利用它们来访问内核地址空间。
中断和异常处理程序的嵌套执行
每个中断或异常都会引起一个内核控制路径，或者说代表当前进程在内核态执行单独的

