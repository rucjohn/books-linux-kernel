# 初始化中断描述符表

现在，我们知道了 80x86 微处理器在硬件级对中断和异常做了些什么，接下来，我们可以继续描述如何初始化中断描述符表。

**内核启用中断以前，必须把 IDT 表的初始地址装到 ldtr寄存器，并初始化表中的每项**。这项工作是在初始化系统时完成的（参见附录一）。

int 指令允许用户态进程发出一个中断信号，其值可以是 0-255 的任意一个向量。因此，为了防止用户通过int指令模拟非法的中断和异常，IDT 的初始化必须非常小心。这可以通过把中断或陷阵门描述符的 DPL 字段设置成 0 来实现。如果进程试图发出其中的一个中断信号，控制单元将检查出 CPL 的值与 DPL 字段有冲突，并且产生一个 “General protection” 异常。

然而，在少数情况下，用户态进程必须能发出一个编程异常。为此，只要把中断或陷阴门描述符的DPL字段设置成3，即特权级尽可能一样高就足够了。

现在，让我们来看一下 Linux 是如何实现这种策略的。

## 中断门、陷阴门及系统门

与在前面 “中断描述符表” 中所提到的一样，Intel 提供了三种类型的中断描述符：任务门、中断门及陷阱门描述符。Linux 使用与 Intel 稍有不同的细目分类和术语，把它们如下进行分类：
* *中断门（interrupt gate）*  
用户态的进程不能访问的一个 Intel 中断门（门的 DPL 字段为 0）。所有的 Linux 中断处理程序都通过中断门激活，并全部限制在内核态。  
&emsp;

* *系统门（system gate）*
用户态的进程可以访问的一个 Intel 陷阱门（门的 DPL 字段为 3）。通过系统门来激活三个 Linux 异常处理程序，它们的向量是 4，5 及 128，因此，在用户态下，可以发布 into、bound 及 ints 0×80 三条汇编语言指令。  
&emsp;

* *系统中断门（system interrupt gate）*  
能够被用户态进程访问的 Intel 中断门（门的 DPL 字段为 3）。与向量 3 相关的异常处理程序是由系统中断门激活的，因此，在用户态可以使用汇编语言指令 int 3。  
&emsp;

* *陷阱门（trap gate）*  
用户态的进程不能访问的一个 Intel 陷阱门（门的 DPL 字段为 0）。大部分 Linux 异常处理程序都通过陷阱门来激活。  
&emsp;

* *任务门（task gate）*  
不能被用户态进程访问的 Intel 任务门（门的 DPL 字段为 0）。Linux 对 “Double fault” 异常的处理程序是由任务门激活的。  
&emsp;

下列体系结构相关的函数用来在IDT中插入门：
* `Set_intr_gate(n, addr）`  
在 IDT 的第 n 个表项插入一个中断门。门中的段选择符设置成内核代码的段选择符，偏移量设置为中断处理程序的地址 addr，DPL 字段设置为 0。  
&emsp;

* `set_system_gate(n, addr）`  
在 IDT 的第 n 个表项插人一个陷阱门。门中的段选择符设置成内核代码的段选择符，偏移量设置为异常处理程序的地址 adar，DPL 字段设置为 3。  
&emsp;

* `set_system_intr_gate(n,addr）`  
在 IDT 的第 n 个表项插入一个中断门。门中的段选择符设置成内核代码的段选择符，偏移量设置为异常处理程序的地址 addr，DPL 字段设置为 3。  
&emsp;

* `set_trap_gate(n, addr）`  
与前一个函数类似，只不过 DPL 的字段设置成 0。  
&emsp;

* `set_task_gate(n, gdt）`
在 IDT 的第 n 个表项中插入一个中断门。门中的段选择符中存放一个 TSS 的全局描述符表的指针，该 TSS 中包含要被激活的函数。偏移量设置为 0，而 DPL 字段设置为 3。


## IDT 的初步初始化

当计算机还运行在实模式时，IDT 被初始化并由 BIOS 例程使用。然而，一且 Linux 接管，IDT 就被移到 RAM 的另一个区域，并进行第二次初始化，因为 Linux 没有利用任何 BIOS 例程（参见附录一）。

IDT 存放在 idt_table 表中，有 256 个表项。6 字节的 idt_descr 变量指定了 IDT 的大小和它的地址，只有当内核用 lidt 汇编指令初始化 iatr 寄存器时才用到这个变量。

> 一些旧的 Pentium 模式有声名狼籍的 “f00f” bug，能让用户态程序冻结系统。当 Linux在这样的 CPU 上执行时，就使用工作区，而该工作区基于用指向实际 IDT 的只读固定映射线性地址初始化 idtr 寄存器（参见第二章 “固定映射的线性地址” 一节）。

在内核初始化过程中，`setup_idt()` 汇编语言函数用同一个中断门（即指向 `ignore_int()` 中断处理程序）来填充所有这 256 个 idt_table 表项：

```
setup_idt:
    lea ignore_int，%edx
    movl $(_ _KERNEL_CS << 16), %eax
    movw %dx, %ax       /* selector = 0x0010 = cs */
    movw $0x8e00, %dx   /* interrupt gate, dpl=0, present */
    lea idt_table, %edi
    mov $256, %ecx
rp_sidt：
    movl %eax, (%edi)
    movl %edx, 4(%edi)
    addl $8, %edi
    dec %ecx
    jne rp_sidt
   ret
```

用汇编语言写成的 `ignore_int()` 中断处理程序，可以看作一个空的处理程序，它执行下列动作：  
1. 在栈中保存一些寄存器的内容。  
2. 调用 `printk()` 函数打印 “Unknown interrupt” 系统消息。  
3. 从栈恢复寄存器的内容。  
4. 执行 iret 指令以恢复被中断的程序。

`ignore_int()` 处理程序应该从不被执行，在控制台或日志文件中出现的 “Unknown interrupt” 消息标志着要么是出现了一个硬件的问题（一个 I/O 设备正在产生没有预料到的中断），要么就是出现了一个内核的问题（一个中断或异常未被适当地处理）。

紧接着这个预初始化，内核将在 IDT 中进行第二遍初始化，用有意义的陷阴和中断处理程序替换这个空处理程序。一且这个过程完成，对控制单元产生的每个不同的异常，IDT 都有一个专门的陷阱或系统门，而对于可编程中断控制器确认的每一个 IRQ，IDT 都将包含一个专门的中断门。

在接下来的两节中，将分别针对异常和中断来详细地说明这个工作是如何完成的。
