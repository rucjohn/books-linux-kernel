### 内存管理

内存管理是迄今为止 Unix 内核中最复杂的活动。在本书中，我们将用超过三分之一的篇幅来描述 Linux 是如何实现它的。本节只说明一些与内存管理相关的主要问题。

#### 虚拟内存

所有新迈的 Unix 系统都提供了一种有用的抽象，叫虚拟内存（*virtual memory*）。虚拟内存作为一种逻辑层，处于应用层的内存请求与硬件内存管理单元（MemoryManagement Unit, MMU）之间。虚拟内存有很多有用用途和优点：

- 若干个进程可以并发地执行。
- 应用程序所需内存大于可用物理内存时也可以运行。
- 程序只有部分代码装入内存时进程可以执行它。
- 允许每个进程访问可用物理内存的子集。
- 进程可以共享库函数或程序的一个单独内存映像。
- 程序是可重定位的，也就是说，可以把程序在物理内存的任何地方。
- 程序员可以编写与机器无关的代码，因为他们不必关心有关物理内存的组织结构。

虚拟内存子系统的主要成分是虚拟地址空间（*virtual address space*）的概念。进程所用的一组内存地址不同于物理内存地址。当进程使用一个虚拟地址时，内核和 MMU 协同定位其在内存中的实际物理位置。

现在的 CPU 包含了能自动把虚拟地址转换成物理地址的硬件电路。为了达到这个目标，把可用 RAM 划分成长度为 4KB 或 8KB 的页框（page frame），并且引入一组页表来指定虚拟地址与物理地址之间的对应关系。这些电路使内存分配变得简单，因为一块连续的虚拟地址请求可以通过分配一组非连续的物理地址页框而得到满足。

#### 随机访问存储器（RAM）的使用

所有的 Unix 操作系统都将 RAM 毫无疑义得划分为两部分，其中若干兆字节专门用于存放内核映像（也就是内核代码和内核静态数据结构）。RAM 的其余部分通常由虚拟内存系统来处理。并且用在以下三种可能的方面：

- 满足内核对缓冲区、描述符及其他动态内核数据结构的请求。
- 满足进程对一般内存区的请求及对文件内存映射的请求。
- 借助于高速缓存从磁盘及其他缓冲设备获得较好的性能。

每种请求类型都是重要的。但从另一方面来说，因为可用 RAM 是有限的，所以必须在请求类型之间做出平衡，尤其是当可用内存没有余下多少时。此外，当可用内存达到临界阀值时，可以调用页框回收（page-frame-reclaiming）算法释放其他内存，那么哪些页框是最适合回收的页框呢？正如我们将在第十七章中看到的一样，对这个问题既没有简单的答案，也没有多少理论的支持，唯一可用的解决办法是开发经过仔细调节的经验算法。

虚拟内存系统必须解决的一个主要问题是内存碎片。理想情况下，只有当空闲页框数太少时，内存请求才失败。然而，通常要求内核使用物理上连续的内存区域，因此，即使有足够的可用内存，但它不能作为一个连续的大块使用时，内存的请求也会失败。

#### 内核内存分配器

内核内存分配器（*Kernel Memory Allocator, KMA*）是一个子系统，它试图满足系统中所有部分对内存的请求。其中一些请求来自内核其他子系统，它们需要一些内核使用的内存，还有一些请求来自用户程序的系统调用，用来增加用户进程的地址空间。一个好的 KMA 应用具有下列特点：

- 必须快。实际上，这是最重要的属性，因为它由所有的内核子系统（包括中断处理程序）调用。
- 必须把内存的浪费减少到最少。
- 必须努力减轻内存的碎片（fragmentation）问题。
- 必须能与其他内存管理子系统合作，以便借用和释放页框。

&emsp;

基于各种不同的算法技术，已经提出了几种 KMA，包括：
- 资源图分配算法（allocator）
- 2的幂次方空闲链表
- McKusick-Karels 分配算法
- 伙伴（Buddy）系统
- Mach 的区域（Zone）分配算法
- Dynix 分配算法
- Solaris 的 Slab 分配算法

我们将在第十八章中看到，Linux 的 KMA 在伙伴系统之上采用了 Slab 分配算法。

#### 进程虚拟地址空间处理

进程的虚拟地址空间包括了进程可以引用的所有虚拟内存地址。内核通常用一组内存区描述符描述进程虚拟地址空间。例如，当进程通过 `exec()` 类系统调用开始某个程序的执行时，内核分配给进程的虚拟地址空间由以下内存区组成：
- 程序的可执行代码
- 程序的初始化数据
- 程序的未初始化数据
- 初始程序栈（即用户态栈）
- 所需共享库的可执行代码和数据
- 堆（由程序动态请求的内存）

所有现代 Unix 操作系统都采用了所谓请求调页（*demand paging*）的内存分配策略。有了请求调页，进程可以在它的页还没有在内存时就开始执行。当进程访问一个不存在的页时，MMU 产生一个异常；异常处理程序找到受影响的内存区，分配一个空闲的页，并用适当的数据把它初始化。同理，当进程通过调用 `malloc()` 或 `brk()`（由 `malloc()` 在内部调用）系统调用动态地请求内存时，内核仅仅修改进程的堆内存区的大小。只有试图引用进程的虚拟内存地址而产生异常时，才给进程分配页框。

虚拟地址空间也采用其他更有效的策略，如前面提到的写时复制策略。例如，当一个新进程被创建时，内核仅仅把父进程的页框赋予给子进程的地址空间，但是把这些页框标记为已读。一旦父或子进程试图修改页中的内容时，一个异常就会产生。异常处理程序把新页框赋给受影响的进程，并用原来页中的内容初始化新页框。

#### 高速缓存

物理内存的一大优势就是用作磁盘的其他块设备的高速缓存。这是因为硬盘非常慢：磁盘的访问需要数据毫秒，与 RAM 的访问时间相比，这太长了。因此，磁盘通常是影响系统性能的瓶颈。通常，在最早的 Unix 系统中就已经实现的一个策略是：尽可能地推迟写磁盘的时间，因此，从磁盘读入内存的数据即使任何进程都不再使用它们，它们也继续留在 RAM 中。

这一策略的前提是有好机会摆在前面：新进程请求从磁盘读或写的数据，就是被撤消进程曾拥有的数据。当一个进程请求访问磁盘时，内核首先检查进程请求的数据是否在缓存中，如果在（把这种情况叫做缓存命中），内核就可以为进程请求提供服务而不用访问磁盘。

`sync()` 系统调用把所有 “脏” 的缓冲区（即缓冲区的内容与对应磁盘块的内容不一样）写入磁盘来强制磁盘同步。为了避免数据丢失，所有的操作系统都会注意周期性地把脏缓冲区写回磁盘。
