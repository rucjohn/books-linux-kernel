### 进程管理

Unix 在进程和它正在执行的程序之间做出一个清晰的划分。`fork()` 和 `_exit()` 系统调用分别用来创建一个新进程和终止一个进程，而调用 `exec()` 类系统调用则是装入一个新程序。当这样一个系统调用执行以后，进程就在所装入程序的全新地址空间恢复运行。

调用 `fork()` 的进程是父进程，而新进程是它的子进程。父子进程能互相找到对方，因为描述每个进程的数据结构都包含有两个指针，一个是直接指向它的父进程，另一个直接指向它的子进程。

实现 `fork()` 一种天真的方式就是将父进程的数据与代码都复制，并把这个拷贝赋予子进程。这会相当费时。当前依赖硬件分布单元的内核采用写时复制（Copy-On-Write）技术，即把页的复制延迟到最后一刻（也就是说，直到父或子进程需要写一个页时才复制这个页）。我们将在第九章 “写时复制” 一节中描述 Linux 是如何实现这一技术的。

`_exit()` 系统调用终止一个进程。内核对这个系统调用的处理是通过释放进程所拥有的资源并向父进程发送 `SIGCHLD` 信号（默认操作为忽略）来实现的。

#### 僵死进程（zombie process）

父进程如何查询其子进程是否终止呢？`wait4()` 系统调用允许进程等待，直到其中的一个子进程结束；它返回已终止子进程的进程标识符（Process ID，PID）。

内核在执行这个系统调用时，检查子进程是否已经终止。引入僵死进程的特殊状态是为了表示进程终止的进程：父进程执行完 `wait4()` 系统调用之前，进程就一直停留在那种状态。系统调用处理程序从进程描述符字段中获取有关资源使用的一些数据；一旦得到数据，就可以释放进程描述符。当进程执行 `wait4()` 系统调用时如果没有子进程结束，内核就通常把该进程设置成等待状态，一直到子进程结束。

很多内核也实现了 `waitpid()` 系统调用，它允许进程等待一个特殊的子进程。其他 `wait4()` 系统调用的变体也是相当通用的。

在父进程发出 `wait4()` 调用之前，让内核保存子进程的有关信息是一个良好的习惯，但是，假设父进程终止而没有发出 `wait4()` 调用呢？这些信息占用了一些内存中非常有用的位置，而这些位置本来可以用来为活动着的进程提供服务。例如，很多 shell 允许用户在后台启动一个命令然后退出。正在运行这个 shell 命令的进程终止，但它的子进程继续运行。

解决的办法是使用一个名为 *init* 的特殊进程，它在系统初始化的时候被创建。当一个进程终止时，内核改变其所有现有子进程的进程描述符指针，使这些子进程成为 *init* 的孩子。*init* 监控所有子进程的执行，并且按常规发布 `wait4()` 系统调用，其副作用就是除掉所有僵死的进程。

#### 进程组和登录会话

现代 Unix 操作系统引入进程组（*process group*）的概念，以表示一种 “作业（job）” 的抽象。例如，为了执行命令行：
```
ls | sort | more
```
Shell 支持进程组，例如 `bash`，为了三个相应的进程 `ls`、`sort` 及 `more` 创建了一个新的组。shell 以这种方式作用于这三个进程，就好像它们是一个单独的实例（更准确地说是作业）。每个进程描述符包括一个进程组 ID 的字段。每一进程组可以有一个领头进程（即其 PID 与这个进程组的 ID 相同的进程）。新创建的进程最初被插入到其父进程的进程组中。

现代 Unix 内核也引入登录会话（*login session*）。非正式地说，一个登录会话包含在指定终端已经开始工作会话的那个进程的所有后代进程 --- 通常情况下，登录会话就是 shell 进程为用户创建的第一条命令。进程组中所有的进程必须在同一登录会话中。一个登录会话可以让几个进程组同时处于活动状态，其中，只有一个进程组一直处于前台，这意味着该进程组可以访问终端，而其他活动着的进程组在后台。当一个后台进程试图访问终端时，它将收到 `SIGTTIN` 或 `SIGTTOU` 信号。在很多 shell 命令中，用内部命令 `bg` 和 `fg` 把一个进程放到后台或者前台。
