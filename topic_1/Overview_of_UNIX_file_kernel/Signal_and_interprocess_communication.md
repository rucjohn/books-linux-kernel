### 信号和进程间通信

Unix 信号（*signal*）提供了把系统事件报告给进程的一种机制。每种事件都有自己信号编号，通常用一个符号常量来表示，例如 `SIGTERM`。有两种事件：

* *异步通告*  
例如，当用户在终端按下中断键（通常为 CTRL-C）。即向前台进程发出中断信号 `SIGINT`。  
&emsp;  

* *同步错误或异常*  
例如，当进程访问内存非法地址时，内核向这个进程发送一个 `SIGSEGV` 信号。  
&emsp;  

POSIX 标准定义了大约 20 种不同的信号，其中，有两种是用户自定义的，可以当作用户态下进程通信和同步的原语机制。一般来说，进程可以以两种方式对接收的信号做出反应：
- 忽略该信号。
- 异步地执行一个指定的过程（信号处理程序）。

&emsp;  

如果进程不指定选择何种方式，内核就根据信号的编号执行一个默认操作。五种可能的默认操作是：
- 终止进程。
- 将执行上下文和进程地址空间的内容写入一个文件（核心转储，core dump），并终止进程。
- 忽略信号。
- 挂起进程。
- 如果进程曾被暂停，则恢复它的执行。

因为 POSIX 语义允许进程暂时阻塞信号，因此内核信号的处理相当精细。此外，SIGKILL 和 SIGSTOP 信号不能直接由进程处理，也不能由进程忽略。

AT&T 的 Unix System V 引入了用户态下其他种类的进程间通信机制，很多 Unix 内核也采用了这些机制：信号量、消息队列及共享内存。它们被统称为 *System V IPC*。

内核把它们作为 *IPC* 资源来实现：进程要获得一个资源，可以调用 `shmget()`、`semget()`、或`msgget()` 系统调用。与文件一样，IPC 资源是持久不变的，进程创建者、进程拥有者或超级用户进程必须显式地释放这些资源。

这里的信号量与本章 “同步和临界区” 一节中所描述的信号量是相似的，只是它们用在用户态下的进程。消息队列允许进程利用 `msgsnd()` 及 `msgget()` 系统调用交换消息，`msgsnd()`表示将消息插入到指定的队列中，`msgget()`表示从队列中提取消息。

POSIX 标准（IEEE Std 1003.1-2001）定义了一种基于消息队列的 IPC 机制，这就是所谓的 POSIX 消息队列。它们和 System V IPC 消息队列是相似的，但是，它们对应用程序提供一个更简单的基于文件的接口。

共享内存为进程之间交换和共享数据提供了最快的方式。通过调用 `shmget()` 系统调用来创建一个新的共享内存，其大小按需设置。在获得 IPC 资源标识符后，进程调用 `shmat()` 系统调用，其返回值是进程的地址空间中新区域的起始地址。当进程希望把共享内存从其地址空间分离出去时，就调用 `shmdt()` 系统调用。共享内存的实现依赖于内核对进程地址空间的实现。
