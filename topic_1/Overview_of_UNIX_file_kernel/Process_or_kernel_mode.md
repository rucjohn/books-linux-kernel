### 进程/内核模式

如前所述，CPU 既可以运行在用户态下，也可以运行在内核态下。实际上，一些 CPU 可以有两种以上的执行状态。例如，Intel 80x86 微处理器有四种不同的执行状态。但是，所有标准的 Unix 内核都仅仅利用了内核态和用户态。

当一程序在用户态下执行时，它不能直接访问内核数据结构和内核的程序。然而，当应用程序在内核态下运行时，这些限制不再有效。每种 CPU 模型都为从用户态到内核态的转换提供了特殊的指令，反之亦然。一个程序执行时，大部分时间都处在用户态下，只有需要内核所提供的服务时才切换到内核态。当内核满足了用户程序的请求后，它让程序又回到用户态下。

进程是动态的实体，在系统内通常只有有限的生存期。创建、撤消及同步现有进程的任务都委托给内核中的一组例程来完成。

内核本身并不是一个进程，而是进程的管理者。进程/内核模式假定：请求内核服务的进程使用所谓系统调用（*system call*）的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的 CPU 指令完成从用户态到内核态的转换。

除用户进程之外，Unix 系统还包括几个所谓内核线程（*kernel thread*）的特权进程（被赋予特殊权限的进程），它们具有以下特点：
- 它们以内核态运行在内核地址空间。
- 它们不与用户直接交互，因此不需要终端设备。
- 它们通常在系统启动时创建，然后一直处于活跃状态直到系统关闭。

在单处理器系统中，任何时候只有一个进程在运行，它要么处于用户态，要么处于内核态。如果进程运行在内核态，处理器就执行一些内核例程。

图 1-2 举例说明了用户态与内核态之间的相互转换。处于用户态的进程1发出系统调用之后，进程切换到内核态，系统调用被执行。然后，直到发生定时中断且调度程序在内核态被激活，进程1才恢复在用户态下执行。进程切换发生，进程2在用户态下开始执行，直到硬件设备发出中断请求。中断的结果是，进程2切换到内核态并处理中断。

![图 1-2：用户态与内核态之间的转换]()

Unix 内核做的工作远不止处理系统调用。实际上，可以有几种方式激活内核例程：
- 进程调用系统调用。
- 正在执行进程的 CPU 发出一个异常（*exception*）信号，异常是一些反常情况，例如一个无效的指令。内核代表产生异常的进程处理异常。
- 外围设备向 CPU 发出一个中断（*interrupt*）信号以通知一个事件的发生，如一个要求注意的请求、一个状态的变化或一个 I/O 操作已经完成等。每个中断信号都是由内核中的中断处理程序（*interrupt handler*）来处理的。因为外围设备与 CPU 异步操作，因此，中断在不可预知的时间发生。
- 内核线程被执行。因为内核线程运行在内核态，因此必须认为其相应程序是内核的一部分。
