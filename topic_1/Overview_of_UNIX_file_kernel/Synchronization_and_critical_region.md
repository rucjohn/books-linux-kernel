### 同步和临界区

实现可重入内核需要利用同步机制：如果内核控制路径对某个内核数据结构进行操作时被挂起，那么，其他的内核控制路径就不应当再对该数据结构进行操作，除非它已被重新设置成一致性（consistent）状态。否则，两个控制路径的交互作用将破坏所存储的信息。

例如，假设全局变量V包含某个系统资源的可用项数。每个内核控制路径A读这个变量，并且确定仅有一个可用资源项。这时，另一个内核控制路径B被激活，并读同一个变量V，V的值仍为1。因此，B对V减1，并开始用这个资源项。然后，A恢复执行。因为A已经读到V的值，于是它假定自己可以对V减1并获取B已经在使用的这个资源项。结果，V的值变为-1，两个内核控制路径使用相同的资源项有可能导致灾难性的后果。

当某个计算结果取决于如何调度两个或多个进程时，相关代码就是不正确的。我们说存在一种竞争条件（*race condition*）。

一般来说，对全局变量的安全访问通过原子操作（*atomic operation*）来保证。在前面的例子中，如果两个控制路径读V并减1是一个单独的、不可中断的操作，那么，就不可能出现数据讹误。然而，内核包含的很多数据结构是无法用单一操作访问的。例如，用单一的操作从链表中删除一个元素是不可能的，因为内核一次至少访问两个指针。临界区（*critical region*）是这样的一段代码，进入这段代码的进程必须完成，之后另一个进程才能进入。

这些问题不仅出现在内核控制路径之间，也出现在共享公共数据的进程之间。几种同步技术已经被采用。以下将集中讨论怎样同步内核控制路径。

#### 非抢占式内核

当寻找彻底、简单地解决同步问题的方案中，大多数传统的 Unix 内核都是非抢占式的：当进程在内核态执行时，它不能被任意挂起，也不能被另一个进程代替。因此，在单处理器系统上，中断或异常处理程序不能修改的所有内核数据结构，内核对它们的访问都是安全的。

当然，内核态的进程能自愿放弃 CPU，但是在这种情况下，它必须确保所有的数据结构都处于一致性状态。此外，当这种进程恢复执行时，它必须重新检查以前访问过的数据结构的值，因为这些数据结构有可能被改变。

如果内核支持抢占，那么在应用同步机制时，确保进入临界区前禁止抢占，退出临界区时启动抢占。

非抢占式能力在多处理器系统上是低效的，因为运行在不同 CPU 上的两个内核控制路径本可以并发地访问相同的数据结构。

#### 禁止中断

单处理器系统上的另一种同步机制是：在进入一个临界区之前禁止所有硬件中断，离开时再重新启动中断。这种机制尽管简单，但远不是最佳的。如果临界区比较大，那么在一个相对较长的时间内持续禁止中断就可能使所有的硬件活动处于冻结状态。

此外，由于在多处理器系统中禁止本地 CPU 上的中断是不够的，所以必须使用其他的同步技术。

#### 信号量

广泛使用的一种机制是信号量（*semaphore*），它在单处理器系统和多处理器系统上都有效。信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看到一个对象，其组成如下：

- 一个整数变量
- 一个等待进程的链表
- 两个原子方法：`down()` 和 `up()`

`down()`方法对信号量的值减1，如果这个新值小于0，该方法就把正在运行的进程加入到这个信号量链接，然后阻塞该进程（即调用调度程序）。`up()`方法对信号量的值加1，如果这个新值大于或等于0，则激活这个信号量链接表中一个或多个进程。

每个要保护的数据结构都有它自己的信号量，其初始值是1。当内核控制路径希望访问这个数据结构时，它在相应的信号量上执行 `down()` 方法。如果信号量的当前值不是负数，则允许访问这个数据结构。否则，把执行内核控制路径的进程加入到这个信号量的链表并阻塞该进程。当另一个进程在那么个信号量上执行 `up()` 方法时，允许信号量链接上的一个进程继续执行。

#### 自旋锁

#### 避免死锁

