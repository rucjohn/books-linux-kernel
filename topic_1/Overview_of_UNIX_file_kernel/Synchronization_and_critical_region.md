### 同步和临界区

实现可重入内核需要利用同步机制：如果内核控制路径对某个内核数据结构进行操作时被挂起，那么，其他的内核控制路径就不应当再对该数据结构进行操作，除非它已被重新设置成一致性（consistent）状态。否则，两个控制路径的交互作用将破坏所存储的信息。

例如，假设全局变量V包含某个系统资源的可用项数。每个内核控制路径A读这个变量，并且确定仅有一个可用资源项。这时，另一个内核控制路径B被激活，并读同一个变量V，V的值仍为1。因此，B对V减1，并开始用这个资源项。然后，A恢复执行。因为A已经读到V的值，于是它假定自己可以对V减1并获取B已经在使用的这个资源项。结果，V的值变为-1，两个内核控制路径使用相同的资源项有可能导致灾难性的后果。

当某个计算结果取决于如何调度两个或多个进程时，相关代码就是不正确的。我们说存在一种竞争条件（*race condition*）。

一般来说，对全局变量的安全访问通过原子操作（*atomic operation*）来保证。在前面的例子中，如果两个控制路径读V并减1是一个单独的、不可中断的操作，那么，就不可能出现数据讹误。然而，内核包含的很多数据结构是无法用单一操作访问的。例如，用单一的操作从链表中删除一个元素是不可能的，因为内核一次至少访问两个指针。临界区（*critical region*）是这样的一段代码，进入这段代码的进程必须完成，之后另一个进程才能进入。

这些问题不仅出现在内核控制路径之间，也出现在共享公共数据的进程之间。几种同步技术已经被采用。以下将集中讨论怎样同步内核控制路径。

#### 非抢占式内核

当寻找彻底、简单地解决同步问题的方案中，大多数传统的 Unix 内核都是非抢占式的：当进程在内核态执行时，它不能被任意挂起，也不能被另一个进程代替。因此，在单处理器系统上，中断或异常处理程序不能修改的所有内核数据结构，内核对它们的访问都是安全的。

当然，内核态的进程能自愿放弃 CPU，但是在这种情况下，它必须确保所有的数据结构都处于一致性状态。此外，当这种进程恢复执行时，它必须重新检查以前访问过的数据结构的值，因为这些数据结构有可能被改变。

如果内核支持抢占，那么在应用同步机制时，确保进入临界区前禁止抢占，退出临界区时启动抢占。

非抢占式能力在多处理器系统上是低效的，因为运行在不同 CPU 上的两个内核控制路径本可以并发地访问相同的数据结构。

#### 禁止中断

单处理器系统上的另一种同步机制是：在进入一个临界区之前禁止所有硬件中断，离开时再重新启动中断。这种机制尽管简单，但远不是最佳的。如果临界区比较大，那么在一个相对较长的时间内持续禁止中断就可能使所有的硬件活动处于冻结状态。

此外，由于在多处理器系统中禁止本地 CPU 上的中断是不够的，所以必须使用其他的同步技术。

#### 信号量

广泛使用的一种机制是信号量（*semaphore*），它在单处理器系统和多处理器系统上都有效。信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看到一个对象，其组成如下：

- 一个整数变量
- 一个等待进程的链表
- 两个原子方法：`down()` 和 `up()`

`down()`方法对信号量的值减1，如果这个新值小于0，该方法就把正在运行的进程加入到这个信号量链接，然后阻塞该进程（即调用调度程序）。`up()`方法对信号量的值加1，如果这个新值大于或等于0，则激活这个信号量链接表中一个或多个进程。

每个要保护的数据结构都有它自己的信号量，其初始值是1。当内核控制路径希望访问这个数据结构时，它在相应的信号量上执行 `down()` 方法。如果信号量的当前值不是负数，则允许访问这个数据结构。否则，把执行内核控制路径的进程加入到这个信号量的链表并阻塞该进程。当另一个进程在那么个信号量上执行 `up()` 方法时，允许信号量链接上的一个进程继续执行。

#### 自旋锁

在多处理器系统中，信号量并不总是解决同步问题的最佳方案。系统不允许在不同 CPU 上运行的内核控制路径同时访问某些内核数据结构，在这种情况下，如果修改数据结构所需的时间比较短，那么，信号量可能是低效的。为了检查信号量，内核必须把进程插入到信号量链表中，然后挂起它。因为这两种操作比较费时，完成这些操作时，其他的内核控制路径可能已经释放了信号量。

在这些情况下，多处理器操作系统使用了自旋锁（*spin lock*）。自旋锁与信号量非常相似，但没有进程链表；当一个进程发现锁被另一个进程锁着时，它就不停地 “旋转” ，执行一个紧凑的循环指令直到锁打开。

当然，自旋锁在单处理器环境下是无效的。当内核控制路径试图访问一个上锁的数据结构时，它开始无休止循环。因此，内核控制路径可能因为正在修改受保护的数据结构而没有机会继续执行，也没有机会释放这个自旋锁。最后的结果可能是系统挂起。

#### 避免死锁

与其他控制路径同步的进程或内核控制路径很容易进入死锁（*deadlock*）状态。举一个最简单的死锁的例子，进程 p1 获得访问数据结构a的权限，进程 p2 获取访问b的权限，但是 p1 在等待b，而 p2 在等待a。进程之间其他更复杂的循环等待的情况也可能发生。显然，死锁情形会导致受影响的进程或内核控制路径完全处于冻结状态。

只要涉及到内核设计，当所用内核信号量的数据较多时，死锁就成为一个突出问题。在这种情况下，很难保证内核控制路径在各种可能方式下的交错执行不出现死锁状态。有几种操作系统（包括 Linux）通过按规定的顺序请求信号量来避免死锁。
