## Unix 文件系统概述

Unix 操作系统的设计集中反映在其文件系统上，文件系统有几个有趣的特点。因为在后面的章节中会反复提到这个特点，所以我们先回顾最重要的几个特点。

### 文件

Unix 文件是以字节序列组成的信息载体（*container*），内核不解释文件的内容。很多编程的库函数实现了更高级的抽象，例如，由字段构成的记录以及基于关键字编址的记录。然而，这些库中的程序必须依靠内核提供的系统调用。从用户的观点来看，文件被组织在一个树结构的命名空间中，如图 1-1 所示。

![图 1-1：目标树示例](static/directory_tree.jpg)

除了叶节点之外，树的所有节点都表示目录名。目录节点包含它下面文件及目录的所有信息。文件或目录名由除 "/" 和 空字节 "\0" 之外的任意 ASCII 字符序列组成。大多数文件系统对文件名的长度都有限制，通常不能超过 255 个字符。与树的根相对应的目录称为根目录（*root directory*）。按照惯例，它的名字是 "/"。在同一目录中的文件名不能相同，而在不同目录中的文件名可以相同。

Unix 的每个进程都有一个当前工作目录（参见本章后面的 “进程/内核模式” 一节），它属于进程执行上下文（*execution context*），标识出进程所用的当前目录。为了标识一个特定的文件，进程使用路径名（*pathname*），路径名由斜杠及一列指向文件的目录名交替组成。如果路径名的第一个字符是斜杠，那么这个路径就是绝对路径，因为它的起点是根目录。否则，如果第一项是目录名或文件名，那么这个路径就是所谓的相对路径，因为它的起点是进程的当前目录。

当标识文件名时，也用符号 "." 和 ".."。它们分别标识当前工作目录和父目录。如果当前工作目录是根目录，"." 和 ".." 就是一致的。

### 硬链接和软链接

包含在目录中的文件名就是一个文件的硬链接（*hard link*），或简称链接（*Link*）。在同一目录或不同的目录中，同一文件可以有几个链接，因此对应几个文件名。

Unix 命令：
```
ln P1 P2
```

用来创建一个新的硬链接，即为由路径 P1 标识的文件创建一个路径为 P2 的硬链接。

硬链接有两方面的限制：
- 不允许用户给目录创建硬链接。因为这可能把目录树变为环形图，从而就不可能通过名字定位一个文件。
- 只有在同一文件系统中的文件之间才能创建链接。这带来比较大的限制，因为现代 Unix 系统可能包含了多种文件系统，这些文件系统位于不同的磁盘和 / 或分区，用户也许无法知道它们之间的物理划分。

为了克服这些限制，引入了软链接（*soft link*）[也称为符号链接（*symbolic link*）]。符号链接是短文件，这些文件包含有另一个文件的任意一个路径名。路径名可以指向位于任意一个文件或目录，甚至可以指向一个不存在的文件。

Unix 命令：
```
ln -s P1 P2
```

创建一个路径名为 P2 的新软链接，P2 指向路径 P1。当这个命令执行时，文件系统抽出 P2 的目录部分，并在那个目录下创建一个名为 P2 的符号链接类型的新项。这个新文件包含路径名 P1。这样，任何对 P2 的引用都可以被自动转换成指向 P1 的一个引用。

### 文件类型

Unix 文件可以是下列类型之一：
- 普通文件（regular file）
- 目录
- 符号链接
- 面向块的设备文件（block-oriented device file）
- 面向字符的设备文件（character-oriented device file）
- 管道（pipe）和命名管道（named pipe）（也叫 FIFO）
- 套接字（socket）

前三种文件类型是所有 Unix 文件系统的基本类型。其实现将在第十八章详细讨论。

设备文件与 I/O 设备以及集成到内核中的设备驱动程序相关。例如，当程序访问设备文件时，它直接访问与那个文件相关的 I/O 设备（参见第十三章）。

管道和套接字是用于进程间通信的特殊文件（参见本章后面的 “同步和临界区” 一节以及第十九章）。

### 文件描述符与索引节点

Unix 对文件的内容和描述文件的信息给出了清楚的区分。除了设备文件和特殊文件系统文件外，每个文件都由字符序列组成。文件内容不包含任何控制信息，如文件长度或文件结束（end-of-file, EOF）符。

文件系统处理文件需要的所有信息包含在一个名为索引节点（*inode*）的数据结构中。每个文件都有自己的索引节点，文件系统用索引节点来标识文件。

虽然文件系统及内核函数对索引节点的处理可能随 Unix 系统的不同有很大的差异，但它们必须至少提供在 POSIX 标准中指定的如下属性：
- 文件类型（参见第一节）
- 与文件相关的硬链接个数
- 以字节为单位的文件长度
- 设备标识符（即包含文件的设备的标识符）
- 在文件系统中标识文件的索引节点号
- 文件拥有者的 UID
- 文件的用户组 ID
- 几个时间戳，表示索引节点状态改变的时间、最后访问时间及最后修改时间
- 访问权限和文件模式（参见下一节）

### 访问权限和文件模式

文件的潜在用户分为三种类型：
- 作为文件所有者的用户
- 同组用户，不包括所有者
- 所有剩下的用户（其他）

有三种类型的访问权限 --- 读、写及执行每组用户都有这三种权限。因此，文件访问权限的组合就用九种不同的二进制来标识。还有三种附加的标记，即 *suid (Set User ID)*，*sgid (Set Groud ID)*，及 *sticky* 用来定义文件的模式。当这些标识应用到可执行文件有如下含义：

* *suid*  
进程执行一个文件时通常保持进程拥有者的UID。然而，如果设置了可执行文件 suid 的标志位，进程就获得了该文件拥有者的 UID。  
&emsp;  

* *sgid*  
进程执行一个文件时保持进程组的用户组 ID。然而，如果设置了可执行文件 sgid 的标志位，进程就获得了该文件用户组的 ID。  
&emsp;  

* *sticky*  
设置了 sticky 标志位的可执行文件相当于向内核发出一个请求，当程序执行结束以后，依然把它保留在内存。  
&emsp;  

当文件由一个进程创建时，文件拥有者的 ID 就是该进程的 UID。而其用户组的 ID可以是进程创建者的 ID，也可以是父目录的 ID，这取决于父目录的 sgid 标志位的值。

### 文件操作的系统调用

当用户访问一个普通文件或目录文件的内容时，他实际上是访问存储在硬件块设备上的一些数据。从这个意义上说，文件系统是硬盘分区物理组织的用户级视图。因为处于用户态的进程不能直接与低层硬件交互，所以每个实际的文件操作必须在内核态下进行。因此，Unix 操作系统定义了几个与文件操作有关的系统调用。

所有 Uninx 内核都对硬件块设备的处理效率给予极大关注，其目的是为了获得非常好的系统整体性能。在后面的章节中，我们将描述 Linux 与文件操作相关的主题，尤其是讨论内核如何对文件相关的系统调用作出反应。为了理解这些内容，你需要知道如何使用文件操作的主要系统调用。下面对此给予描述。

#### 打开文件

进程只能访问 “打开的” 文件。为了打开一个文件，进程调用系统调用：
```
fd=open(path, flag, mode);
```
其中的三个参数具有以下含义：

* *path*  
表示被打开文件的（相对或绝对）路径。  
&emsp;  

* *flag*  
指定文件打开的方式（例如，读、写、读/写、追加）。它也指定是否就当创建一个不存在的文件。  
&emsp;  

* *mode*  
指定新创建文件的访问权限。  
&emsp;  

这个系统调用创建一个 “打开文件” 对象，并返回所谓文件描述符（*file descriptor*）的标识符。一个打开文件对象包括：
- 文件操作的一些数据结构，如指定文件打开方式的一组标志；表示文件当前位置的 oofset 字段，从这个位置开始将进行下一个操作（即所谓的文件指针），等等。
- 进程可以调用的一些内核函数指针。这组允许调用的函数集合由参数 flag 值决定。

&emsp;  

我们将在第十二章详细讨论打开文件对象。在这里，我们仅描述一些 POSIX 语义所指定的一般特性：
- 文件描述符表示进程与打开文件之间的交互，而打开文件对象包含了与这种交互相关的数据。同一打开文件对象也许由同一个进程的几个文件描述符标识。
- 几个进程也许同时打开同一文件。在这种情况下，文件系统给每个文件分配一个单独的打开文件对象以及单独的文件描述符。当这种情况发生时，Unix 文件系统对进程在同一文件上发出的 I/O 操作之间不提供任何形式的同步机制。然而，有几个系统调用，如 `flock()`，可用来让进程在整个文件或部分文件上对 I/O 操作实施同步（参见第十二章）。

为了创建一个新的文件，进程也可以调用 `create()` 系统调用，它与 `open()` 非常相似，都是由内核来处理。

#### 访问打开的文件

对普通 Unix 文件，可以顺序地访问，也可以随机访问，而对设备文件和命名管道文件，通常只能顺序地访问。在这两种访问方式中，内核把文件指针存储在打开文件对象中，也就是说，当前位置就是下一次进行读或写操作的位置。

顺序访问是文件的默认访问方式，即 `read()` 和 `write()` 系统调用总是从文件指针的当前位置开始读或写。为了修改文件指针的值，必须在程序中显式地调用 `lseek()` 系统调用。当打开文件时，内核让文件指针指向文件的第一个字节（偏移量为 0 ）。

`lseek()` 系统调用需要下列参数：
```
newoffset=lseek(fd, offset, whence);
```

其参数含义如下：

* *fd*  
表示打开文件的文件描述符。  
&emsp;  

* *offset*  
指定一个有符号整数值，用来计算文件指针的新位置。  
&emsp;  

* *whence*  
指定文件指针新位置的计算方式，可以是 offset 加 0，表示文件指针从文件头移动；也可以是 offset 加 文件指针的当前位置，表示文件指针从当前位置移动；还可以是 offset 加文件最后一个字节的位置，表示文件指针从文件末尾开始移动。  
&emsp;  

&emsp;  

`read()` 系统调用需要下列参数：
```
nread=read(fd, buf, count);
```

其参数含义如下：

* *fd*  
表示打开文件的文件描述符。  
&emsp;  

* *buf*  
指定在进程地址空间中缓冲区的地址，所读的数据就放在这个缓冲区。  
&emsp;  

* *count*  
表示所读的字节数。  
&emsp;  

不处理这样的系统调用时，内核会尝试从拥有文件描述符 fd 的文件中读 count 个字节，其起始位置为打开文件的 offset 字段 的当前值。在某些情况下可能遇到文件结束、空管道等等，因此内核无法成功地读出全部 count 个字节。返回的 nread 值就是实际所读的字节数。给原来的值加上 nread 就会更新文件指针。`write()` 的参数和 `read()` 相似。

#### 关闭文件

当进程无需要再访问文件的内容时，就调用系统调用：
```
res=close(fd);
```
释放与文件描述符 fd 相对应的打开文件对象。当一个进程终止时，内核会关闭其所有仍然打开着的文件。

#### 更名及删除文件

要重新命名或删除一个文件时，进程不需要打开它。实际上，这样的操作并没有对这个文件的内容起作用，而是对一个或多个目录的内容起作用。例如，系统调用：
```
res=rename(oldpath, newpath);
```

改变了文件链接 的名字，而系统调用：
```
res=unlink(pathname);
```

减少了文件链接数，删除了相应的目录项。只有当链接数为0，文件才被真正删除。

